/*
 * Functions to evaluate an s-expression. Uses an X macro to generate
 * a computed goto to dispatch the operation.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include "mpc.h"
#include "lilith_int.h"

#define LASSERT(args, cond, err) if (!(cond)) { lval_del(args); return lval_error(err); }
#define LVAL_EXPR_CNT(arg) arg->value.list.count
#define LVAL_EXPR_LST(arg) arg->value.list.cell
#define LVAL_EXPR_ITEM(arg, i) arg->value.list.cell[i]

/*
 * A macro defining the available operations. The first argument is the goto label; the second the name
 * of the function when both params are longs; the third the function for doubles.
 */
#define IOPS $(SUB, sub_l, sub_d) $(MUL, mul_l, mul_d) $(DIV, div_l, div_d) $(ADD, add_l, add_d) \
    $(POW, powl, pow) $(MAX, max_l, max_d) $(MIN, min_l, min_d) $(MOD, mod_l, fmod)

// Arithmetic operations
static long add_l(long x, long y) { return x + y; }
static double add_d(double x, double y) { return x + y; }
static long sub_l(long x, long y) { return x - y; }
static double sub_d(double x, double y) { return x - y; }
static long mul_l(long x, long y) { return x * y; }
static double mul_d(double x, double y) { return x * y; }
static long div_l(long x, long y) { return x / y; }
static double div_d(double x, double y) { return x / y; }
static long max_l(long x, long y) { return x > y ? x : y; }
static double max_d(double x, double y) { return x > y ? x : y; }
static long min_l(long x, long y) { return x < y ? x : y; }
static double min_d(double x, double y) { return x < y ? x : y; }
static long mod_l(long x, long y) { return x % y; }

/**
 * The available operations. Generated by the X macro.
 */
enum iops_enum
{
#define $(X, LOP, DOP) IOPSENUM_##X,
    IOPS
#undef $
};

/**
 * Performs a calculation for two lvals.
 * 
 * @param iop  the operation to perform
 * @param xval the first argument -- freed in this function
 * @param yval the second argument -- freed in this function
 * @returns    a new lval with the result
 */
static lval *do_calc(enum iops_enum iop, lval *xval, lval *yval)
{
    lval *rv;
    static void *jump_table[] =
    {
#define $(X, LOP, DOP) &&JT_##X,
        IOPS
#undef $
    };

    goto *(jump_table[iop]);

#define $(X, LOP, DOP) JT_##X:                                       \
    if (xval->type == LVAL_LONG && yval->type == LVAL_LONG)          \
    {                                                                \
        rv = lval_long(LOP(xval->value.num_l, yval->value.num_l));   \
    }                                                                \
    else if (xval->type == LVAL_LONG)                                \
    {                                                                \
        rv = lval_double(DOP(xval->value.num_l, yval->value.num_d)); \
    }                                                                \
    else if (yval->type == LVAL_LONG)                                \
    {                                                                \
        rv = lval_double(DOP(xval->value.num_d, yval->value.num_l)); \
    }                                                                \
    else                                                             \
    {                                                                \
        rv = lval_double(DOP(xval->value.num_d, yval->value.num_d)); \
    }                                                                \
    lval_del(xval);                                                  \
    lval_del(yval);                                                  \
    return rv;
    IOPS
#undef $
}

static lval *lval_pop(lval *val, int i)
{
    lval *x = LVAL_EXPR_ITEM(val, i);

    // Shift memory after the item at "i" over the top
    memmove(&LVAL_EXPR_ITEM(val, i), &LVAL_EXPR_ITEM(val, i + 1),
        sizeof(lval*) * (LVAL_EXPR_CNT(val) - i - 1));

    // Decrease the count of items in the list
    LVAL_EXPR_CNT(val)--;

    // Reallocate the memory used
    LVAL_EXPR_LST(val) = realloc(LVAL_EXPR_LST(val), sizeof(lval*) * LVAL_EXPR_CNT(val));
    return x;
}

static lval *lval_take(lval *val, int i)
{
    lval *x = lval_pop(val, i);
    lval_del(val);
    return x;
}

/**
 * Built-in function to return the first element of a q-expression.
 */
static lval *builtin_head(lval *val)
{
    LASSERT(val, LVAL_EXPR_CNT(val) == 1, "too many parameters to 'head'");
    LASSERT(val, LVAL_EXPR_ITEM(val, 0)->type == LVAL_QEXPRESSION, "only q-expressions can be passed to 'head'");
    LASSERT(val, LVAL_EXPR_CNT(LVAL_EXPR_ITEM(val, 0)) != 0, "empty q-expression passed to 'head'");

    lval *rv = lval_take(val, 0);
    while (rv->value.list.count > 1)
    {
        lval_del(lval_pop(rv, 1));
    }

    return rv;
}

/**
 * Built-in function to return all elements of a q-expression except the first.
 */
static lval *builtin_tail(lval *val)
{
    LASSERT(val, LVAL_EXPR_CNT(val) == 1, "too many parameters to 'tail'");
    LASSERT(val, LVAL_EXPR_ITEM(val, 0)->type == LVAL_QEXPRESSION, "only q-expressions can be passed to 'tail'");
    LASSERT(val, LVAL_EXPR_CNT(LVAL_EXPR_ITEM(val, 0)) != 0, "empty q-expression passed to 'tail'");

    lval *rv = lval_take(val, 0);
    lval_del(lval_pop(rv, 0));
    return rv;
}

/**
 * Built-in function to evaluate a q-expression.
 */
static lval *builtin_eval(lval *val)
{
    LASSERT(val, LVAL_EXPR_CNT(val) == 1, "too many parameters to 'eval'");
    LASSERT(val, LVAL_EXPR_ITEM(val, 0)->type == LVAL_QEXPRESSION, "only q-expressions can be passed to 'eval'");

    lval *x = lval_take(val, 0);
    x->type = LVAL_SEXPRESSION;
    return lval_eval(x);
}

/**
 * Built-in function to convert an s-expression in to a q-expression.
 */
static lval *builtin_list(lval *val)
{
    val->type = LVAL_QEXPRESSION;
    return val;
}

/**
 * Add all elements of the second q-expression to the first.
 */
static lval *lval_join(lval *x, lval* y)
{
    while (LVAL_EXPR_CNT(y))
    {
        x = lval_add(x, lval_pop(y, 0));
    }

    lval_del(y);
    return x;
}

/**
 * Built-in function to join q-expressions together.
 */
static lval *builtin_join(lval *val)
{
    for (int i = 0; i < LVAL_EXPR_CNT(val); i++)
    {
        LASSERT(val, LVAL_EXPR_ITEM(val, 0)->type == LVAL_QEXPRESSION, "only q-expressions can be passed to 'join'");
    }

    lval *x = lval_pop(val, 0);
    while (LVAL_EXPR_CNT(val))
    {
        x = lval_join(x, lval_pop(val, 0));
    }

    lval_del(val);
    return x;
}

/**
 * Built-in function to return the number of items in a q-expression.
 */
static lval *builtin_len(lval *val)
{
    LASSERT(val, LVAL_EXPR_CNT(val) == 1, "too many parameters to 'len'");
    LASSERT(val, LVAL_EXPR_ITEM(val, 0)->type == LVAL_QEXPRESSION, "only q-expressions can be passed to 'len'");

    lval *x = lval_take(val, 0);
    return lval_long(LVAL_EXPR_CNT(x));
}

static lval *builtin_op(lval *a, const char *op)
{
    // Confirm that all arguments are numeric values
    for (int i = 0; i < LVAL_EXPR_CNT(a); i++)
    {
        if (LVAL_EXPR_ITEM(a, i)->type != LVAL_LONG && LVAL_EXPR_ITEM(a, i)->type != LVAL_DOUBLE)
        {
            lval_del(a);
            return lval_error("cannot operate on non-numeric value");
        }
    }

    // Get the first value
    lval *x = lval_pop(a, 0);

    // If single arument subtraction, negate value
    if (LVAL_EXPR_CNT(a) == 0 && (strcmp(op, "-") == 0))
    {
        if (x->type == LVAL_LONG)
        {
            x->value.num_l = -x->value.num_l;
        }
        else
        {
            x->value.num_d = -x->value.num_d;
        }
    }

    // While elements remain
    while (LVAL_EXPR_CNT(a) > 0)
    {
        lval *y = lval_pop(a, 0);
        if (strcmp(op, "+") == 0)
        {
            x = do_calc(IOPSENUM_ADD, x, y);
        }
        else if (strcmp(op, "-") == 0)
        {
            x = do_calc(IOPSENUM_SUB, x, y);
        }
        else if (strcmp(op, "*") == 0)
        {
            x = do_calc(IOPSENUM_MUL, x, y);
        }
        else if (strcmp(op, "/") == 0)
        {
            if (y->type == LVAL_LONG ? y->value.num_l == 0 : y->value.num_d == 0.0)
            {
                lval_del(x);
                lval_del(y);
                x = lval_error("division by zero");
                break;
            }

            x = do_calc(IOPSENUM_DIV, x, y);
        }
        else if (strcmp(op, "max") == 0)
        {
            x = do_calc(IOPSENUM_MAX, x, y);
        }
        else if (strcmp(op, "min") == 0)
        {
            x = do_calc(IOPSENUM_MIN, x, y);
        }
        else if (strcmp(op, "^") == 0)
        {
            x = do_calc(IOPSENUM_POW, x, y);
        }
        else if (strcmp(op, "%") == 0)
        {
            x = do_calc(IOPSENUM_MOD, x, y);
        }
        else
        {
            lval_del(x);
            lval_del(y);
            x = lval_error("unrecognized operator");
        }
    }

    lval_del(a);
    return x;
}

static lval *builtin(lval *val, const char *func)
{
    if (strcmp("list", func) == 0)
    {
        return builtin_list(val);
    }
    else if (strcmp("head", func) == 0)
    {
        return builtin_head(val);
    }
    else if (strcmp("tail", func) == 0)
    {
        return builtin_tail(val);
    }
    else if (strcmp("join", func) == 0)
    {
        return builtin_join(val);
    }
    else if (strcmp("eval", func) == 0)
    {
        return builtin_eval(val);
    }
    else if (strcmp("len", func) == 0)
    {
        return builtin_len(val);
    }
    else
    {
        return builtin_op(val, func);
    }

    lval_del(val);
}

static lval *lval_eval_sexpr(lval *val)
{
    // Evaluate children
    for (int i = 0; i < LVAL_EXPR_CNT(val); i++)
    {
        LVAL_EXPR_ITEM(val, i) = lval_eval(LVAL_EXPR_ITEM(val, i));
    }

    // Check for errors
    for (int i = 0; i < LVAL_EXPR_CNT(val); i++)
    {
        if (LVAL_EXPR_ITEM(val, i)->type == LVAL_ERROR)
        {
            return lval_take(val, i);
        }
    }

    // Empty expressions
    if (LVAL_EXPR_CNT(val) == 0)
    {
        return val;
    }

    // Single expression
    if (LVAL_EXPR_CNT(val) == 1)
    {
        return lval_take(val, 0);
    }

    // First element must be a symbol
    lval *first = lval_pop(val, 0);
    if (first->type != LVAL_SYMBOL)
    {
        lval_del(first);
        lval_del(val);
        return lval_error("s-expression does not start with symbol");
    }

    // Call built-in with operator
    lval *result = builtin(val, first->value.symbol);
    lval_del(first);
    return result;
}

lval *lval_eval(lval *val) {
    // Evaluate Sexpressions
    if (val->type == LVAL_SEXPRESSION)
    {
        return lval_eval_sexpr(val);
    }

    // All other lval types remain the same
    return val;
}
